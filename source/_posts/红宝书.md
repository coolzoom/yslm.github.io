
---
title: 红宝书
date: 2018-09-09 20:30:11
tags:
---


### 红宝书中关于array 方法的复习
  1. slice方法，这个方法能够基于当前数组中的一个或者多项创建一个新的数组，它不会影响原数组，只会返回一个新的数组
   slice(a,b)//会包含a下标的值但是不会包含b下标的值
   2. splice方法，按红宝书的说法，这个方法恐怕要算是最强大的数组方法了。splice的主要用途是向数组的中部插入项。使用方式有如下三种，删除，插入，替换。
    * 删除，splice(0,5),需要传入两个参数，第一个是起始位置，第二个是要删除的位数，如果第二个参数不传，那么就会一直选择到数组的最后一位，需要注意的是，splice方法会返回一个新的包含删除元素的数组，原来的数组会被改变。


    * 插入，语法如下，arr.splice(2,0,'red','bluue'...) =>第一个是插入的起始位置，第二个是要删除的个数，然后后面都是需要插入的参数了，可以有很多个
    * 替换，替换其实就是依赖插入方法
    *** 重点来了，splice方法的返回值，红宝书上说，splice方法始终会返回一个数组，这个数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组

    3. 位置方法 indexOf()和laseIndexOf()
       说实话，这两个方法有用过，但是确实不太熟悉，这个方法可以传入两个参数，需要查找的项，和（可选的）表示查找起点位置的索引
        console.log(arr.indexOf(1, 2)); //-1
        console.log(arr.indexOf(1, 0)); //0

        console.log(arr.lastIndexOf(2));//1
        console.log(arr.lastIndexOf(2,1)); //1
        console.log(arr.lastIndexOf(0)); //-1
    4. 迭代方法，有五个之多，还是很恐怖的
          * 迭代方法，有五个,从下面的分组就可以看出，分在一组的功能比较相似，但是也还是有所不同
         * some  对数组中的每一项都运行给定的函数，如果有一项返回true，那么整体返回true
         * every every方法比较严格，只有全部项返回都是true，最终结果才会是true，这就像&& 和|| 或/与的区别一样
         *
         * map    对数组中的每一项都执行给定的函数，然后返回结果组成的数组
         * filter 这个返回的不是结果，而是执行函数结果为true的原数组选项，就相当于把数组给过滤了
         *
         * forEach 这个方法就比较熟悉了，就是迭代，这个方法没有返回值哦
    5. 归并方法，reduce()和reduceRight(),这两个方法作用一样，就是遍历的方向不一样，这个方法我一次都没有用过，书中的例子是求数组的和，其他高级应用我现在也搞不明白
       * 来吧，说说reduce这个方法，实践出真知，红宝书上说，reduce方法接受两个参数，第一个就是需要迭代的函数，第二个参数就是初始值
       ```
       var color=[3,2,1,10,5,3,6,9,50,4];

           var res=color.reduce(function (pre,cur,index,array) {
               console.log(pre,cur,index,array);
               return pre+cur;
           },5)
           console.log(res);
           //
            5 3 0 (10) [3, 2, 1, 10, 5, 3, 6, 9, 50, 4]
            8 2 1 (10) [3, 2, 1, 10, 5, 3, 6, 9, 50, 4]
            10 1 2 (10) [3, 2, 1, 10, 5, 3, 6, 9, 50, 4]
            11 10 3 (10) [3, 2, 1, 10, 5, 3, 6, 9, 50, 4]
            21 5 4 (10) [3, 2, 1, 10, 5, 3, 6, 9, 50, 4]
            26 3 5 (10) [3, 2, 1, 10, 5, 3, 6, 9, 50, 4]
            29 6 6 (10) [3, 2, 1, 10, 5, 3, 6, 9, 50, 4]
            35 9 7 (10) [3, 2, 1, 10, 5, 3, 6, 9, 50, 4]
            44 50 8 (10) [3, 2, 1, 10, 5, 3, 6, 9, 50, 4]



           /**
           看上面这个例子，我是传递了两个参数的，我传递了一个5进去，里面的函数呢有四个参数，pre,cur，index,array
           pre 就是上一次迭代的当前值与前以一个值的和，如果传递了参数，那么pre初始值就是传入的参数，不过这样的情况很少，默认都不传
           如果不传地第二个参数，此种情况最常见，那么，默认index就是从1开始算起，这样比较好，此时pre就是第一项了，这样也比较好理解

           cur 就是当前索引对应的值
           index 就是当前索引
           array 就是原数组

           注意，注意，注意吧，重要的事情说三遍，这里区别来了，我传递了参数5，只要我传递了参数，那么索引默认就从0开始，也就是说第一个index是0，那么cur就是3，此时pre是谁呢，3就是原数组中的第一个，还哪儿来的前一个啊，此时第一个pre的值就是传入的参数5，之后，每次迭代，这个pre都会累加

           */


       ```


  ### 说一下，这些都是红宝书第五章的内容，后面还有string字符串这块硬骨头，还需要仔细看看呐，今天先到这儿吧
